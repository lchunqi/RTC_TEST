#include "main.h"
#include "rtc.h"
#include <string.h>
#include "drv_wave1006.h"

#define OTP_LENGTH_SD3900           1024
#define CAP_STEP_2D4			16
#define CAP_STEP_1D2			61
#define CAP_STEP_0D8			118
#define CAP_STEP_0D6			185
#define CAP_STEP_0D4			SD8800_CAP_LIST_MAX
uint8_t g_otpBuffer[OTP_LENGTH_SD3900] = {0xff};
uint8_t g_capList[SD8800_CAP_LIST_MAX + 1][2] = {

	{0x18,0x00},
	{0x18,0x02},
	{0x18,0x04},
	{0x18,0x0a},
	{0x18,0x07},
	{0x18,0x18},
	{0x18,0x0f},
	{0x18,0x1b},
	{0x18,0x1d},
	{0x18,0x26},
	{0x18,0x38},
	{0x18,0x2e},
	{0x18,0x36},
	{0x18,0x37},
	{0x18,0x3e},
	{0x18,0x41},
	{0x18,0x48},
	{0x18,0x49},
	{0x18,0x4a},
	{0x18,0x51},
	{0x18,0x52},
	{0x18,0x4d},
	{0x18,0x4e},
	{0x18,0x61},
	{0x18,0x62},
	{0x18,0x5c},
	{0x18,0x64},
	{0x18,0x70},
	{0x18,0x66},
	{0x18,0x6b},
	{0x18,0x78},
	{0x18,0x73},
	{0x18,0x79},
	{0x18,0x6f},
	{0x18,0x7b},
	{0x18,0x77},
	{0x18,0x7d},
	{0x18,0x81},
	{0x18,0x82},
	{0x18,0x88},
	{0x18,0x89},
	{0x18,0x90},
	{0x18,0x91},
	{0x18,0x87},
	{0x18,0x98},
	{0x18,0x94},
	{0x18,0xa1},
	{0x18,0xa2},
	{0x18,0x9b},
	{0x18,0xa4},
	{0x18,0x9d},
	{0x18,0xa6},
	{0x18,0xb2},
	{0x18,0xb8},
	{0x18,0xb9},
	{0x18,0xba},
	{0x18,0xb6},
	{0x18,0xbc},
	{0x18,0xbd},
	{0x18,0xbe},
	{0x18,0xbf},
	{0x18,0xc1},
	{0x18,0xc2},
	{0x18,0xc8},
	{0x18,0xc4},
	{0x18,0xc9},
	{0x18,0xca},
	{0x18,0xc6},
	{0x18,0xd1},
	{0x18,0xd2},
	{0x18,0xd8},
	{0x18,0xd4},
	{0x18,0xd9},
	{0x18,0xda},
	{0x18,0xe2},
	{0x18,0xdb},
	{0x18,0xe3},
	{0x18,0xe9},
	{0x18,0xe5},
	{0x18,0xe6},
	{0x18,0xeb},
	{0x18,0xe7},
	{0x18,0xed},
	{0x18,0xf9},
	{0x18,0xee},
	{0x18,0xf5},
	{0x18,0xef},
	{0x18,0xfc},
	{0x18,0xf7},
	{0x18,0xfd},
	{0x18,0xfe},
	{0x19,0x08},
	{0x18,0xff},
	{0x19,0x10},
	{0x19,0x0a},
	{0x19,0x11},
	{0x19,0x12},
	{0x19,0x18},
	{0x19,0x13},
	{0x19,0x19},
	{0x19,0x15},
	{0x19,0x22},
	{0x19,0x1b},
	{0x19,0x24},
	{0x19,0x1d},
	{0x19,0x25},
	{0x19,0x31},
	{0x19,0x32},
	{0x19,0x27},
	{0x19,0x33},
	{0x19,0x2e},
	{0x19,0x3a},
	{0x19,0x2f},
	{0x19,0x3b},
	{0x19,0x37},
	{0x19,0x3d},
	{0x19,0x3e},
	{0x19,0x40},
	{0x19,0x3f},
	{0x19,0x41},
	{0x19,0x42},
	{0x19,0x42},
	{0x19,0x48},
	{0x19,0x44},
	{0x19,0x49},
	{0x19,0x45},
	{0x19,0x46},
	{0x19,0x46},
	{0x19,0x52},
	{0x19,0x47},
	{0x19,0x60},
	{0x19,0x54},
	{0x19,0x59},
	{0x19,0x5a},
	{0x19,0x62},
	{0x19,0x68},
	{0x19,0x5c},
	{0x19,0x70},
	{0x19,0x5d},
	{0x19,0x6a},
	{0x19,0x66},
	{0x19,0x6b},
	{0x19,0x5f},
	{0x19,0x67},
	{0x19,0x74},
	{0x19,0x6e},
	{0x19,0x75},
	{0x19,0x6f},
	{0x19,0x76},
	{0x19,0x7c},
	{0x19,0x80},
	{0x19,0x7d},
	{0x19,0x81},
	{0x19,0x7e},
	{0x19,0x82},
	{0x19,0x7f},
	{0x19,0x83},
	{0x19,0x89},
	{0x19,0x90},
	{0x19,0x8a},
	{0x19,0x91},
	{0x19,0x8b},
	{0x19,0x98},
	{0x19,0x8d},
	{0x19,0x94},
	{0x19,0xa1},
	{0x19,0x9a},
	{0x19,0x8f},
	{0x19,0x9b},
	{0x19,0xa4},
	{0x19,0xb0},
	{0x19,0xaa},
	{0x19,0xb1},
	{0x19,0xa6},
	{0x19,0xb8},
	{0x19,0xa7},
	{0x19,0xb3},
	{0x19,0xae},
	{0x19,0xba},
	{0x19,0xb5},
	{0x19,0xbb},
	{0x19,0xbc},
	{0x19,0xb7},
	{0x19,0xbd},
	{0x19,0xc0},
	{0x19,0xc0},
	{0x19,0xbf},
	{0x19,0xbf},
	{0x19,0xc1},
	{0x19,0xc2},
	{0x19,0xc2},
	{0x19,0xc8},
	{0x19,0xc3},
	{0x19,0xc4},
	{0x19,0xc9},
	{0x19,0xc9},
	{0x19,0xc5},
	{0x19,0xd1},
	{0x19,0xc6},
	{0x19,0xd2},
	{0x19,0xd8},
	{0x19,0xc7},
	{0x19,0xd4},
	{0x19,0xd3},
	{0x19,0xe1},
	{0x19,0xce},
	{0x19,0xe2},
	{0x19,0xe8},
	{0x19,0xd6},
	{0x19,0xdb},
	{0x19,0xf0},
	{0x19,0xd7},
	{0x19,0xea},
	{0x19,0xdd},
	{0x19,0xf1},
	{0x19,0xe6},
	{0x19,0xf2},
	{0x19,0xf8},
	{0x19,0xdf},
	{0x19,0xe7},
	{0x19,0xf4},
	{0x19,0xee},
	{0x19,0xfa},
	{0x1a,0x00},
	{0x19,0xf6},
	{0x19,0xef},
	{0x1a,0x01},
	{0x1a,0x02},
	{0x1a,0x08},
	{0x19,0xfd},
	{0x19,0xfe},
	{0x1a,0x04},
	{0x1a,0x10},
	{0x1a,0x0a},
	{0x1a,0x05},
	{0x1a,0x11},
	{0x1a,0x06},
	{0x1a,0x18},
	{0x1a,0x20},
	{0x1a,0x07},
	{0x1a,0x14},
	{0x1a,0x19},
	{0x1a,0x0e},
	{0x1a,0x22},
	{0x1a,0x28},
	{0x1a,0x0f},
	{0x1a,0x1b},
	{0x1a,0x24},
	{0x1a,0x30},
	{0x1a,0x17},
	{0x1a,0x25},
	{0x1a,0x1e},
	{0x1a,0x2b},
	{0x1a,0x38},
	{0x1a,0x1f},
	{0x1a,0x27},
	{0x1a,0x39},
	{0x1a,0x39},
	{0x1a,0x3a},
	{0x1a,0x35},
	{0x1a,0x35},
	{0x1a,0x3b},
	{0x1a,0x3c},
	{0x1a,0x3c},
	{0x1a,0x37},
	{0x1a,0x3d},
	{0x1a,0x3e},
	{0x1a,0x3e},
	{0x1a,0x40},
	{0x1a,0x40},
	{0x1a,0x3f},
	{0x1a,0x41},
	{0x1a,0x41},
	{0x1a,0x42},
	{0x1a,0x48},
	{0x1a,0x48},
	{0x1a,0x43},
	{0x1a,0x50},
	{0x1a,0x4a},
	{0x1a,0x45},
	{0x1a,0x51},
	{0x1a,0x46},
	{0x1a,0x58},
	{0x1a,0x60},
	{0x1a,0x47},
	{0x1a,0x59},
	{0x1a,0x61},
	{0x1a,0x5a},
	{0x1a,0x62},
	{0x1a,0x55},
	{0x1a,0x5b},
	{0x1a,0x63},
	{0x1a,0x70},
	{0x1a,0x6a},
	{0x1a,0x71},
	{0x1a,0x5e},
	{0x1a,0x78},
	{0x1a,0x6c},
	{0x1a,0x5f},
	{0x1a,0x73},
	{0x1a,0x74},
	{0x1a,0x6d},
	{0x1a,0x7a},
	{0x1a,0x75},
	{0x1a,0x75},
	{0x1a,0x7c},
	{0x1a,0x7c},
	{0x1a,0x80},
	{0x1a,0x80},
	{0x1a,0x7e},
	{0x1a,0x81},
	{0x1a,0x81},
	{0x1a,0x7f},
	{0x1a,0x88},
	{0x1a,0x88},
	{0x1a,0x83},
	{0x1a,0x83},
	{0x1a,0x90},
	{0x1a,0x8a},
	{0x1a,0x91},
	{0x1a,0x86},
	{0x1a,0x8b},
	{0x1a,0xa0},
	{0x1a,0x87},
	{0x1a,0x8d},
	{0x1a,0x9a},
	{0x1a,0xa2},
	{0x1a,0x95},
	{0x1a,0x8f},
	{0x1a,0xb0},
	{0x1a,0xa9},
	{0x1a,0x97},
	{0x1a,0xb1},
	{0x1a,0x9e},
	{0x1a,0xb8},
	{0x1a,0xac},
	{0x1a,0x9f},
	{0x1a,0xb3},
	{0x1a,0xb4},
	{0x1a,0xba},
	{0x1a,0xae},
	{0x1a,0xb5},
	{0x1a,0xbc},
	{0x1a,0xbc},
	{0x1a,0xb7},
	{0x1a,0xbd},
	{0x1a,0xbd},
	{0x1a,0xbe},
	{0x1a,0xc0},
	{0x1a,0xbf},
	{0x1a,0xc1},
	{0x1a,0xc1},
	{0x1a,0xc2},
	{0x1a,0xc8},
	{0x1a,0xc8},
	{0x1a,0xc3},
	{0x1a,0xc9},
	{0x1a,0xca},
	{0x1a,0xd1},
	{0x1a,0xc6},
	{0x1a,0xe0},
	{0x1a,0xe0},
	{0x1a,0xd3},
	{0x1a,0xe1},
	{0x1a,0xda},
	{0x1a,0xe8},
	{0x1a,0xd5},
	{0x1a,0xcf},
	{0x1a,0xe9},
	{0x1a,0xd7},
	{0x1a,0xf1},
	{0x1a,0xe5},
	{0x1a,0xf8},
	{0x1a,0xec},
	{0x1a,0xf3},
	{0x1a,0xf3},
	{0x1a,0xfa},
	{0x1a,0xee},
	{0x1b,0x00},
	{0x1a,0xfb},
	{0x1a,0xfc},
	{0x1b,0x01},
	{0x1a,0xf7},
	{0x1b,0x08},
	{0x1a,0xfe},
	{0x1b,0x10},
	{0x1a,0xff},
	{0x1b,0x0a},
	{0x1b,0x11},
	{0x1b,0x18},
	{0x1b,0x20},
	{0x1b,0x07},
	{0x1b,0x19},
	{0x1b,0x21},
	{0x1b,0x0e},
	{0x1b,0x15},
	{0x1b,0x0f},
	{0x1b,0x30},
	{0x1b,0x29},
	{0x1b,0x17},
	{0x1b,0x25},
	{0x1b,0x38},
	{0x1b,0x26},
	{0x1b,0x39},
	{0x1b,0x34},
	{0x1b,0x3a},
	{0x1b,0x2e},
	{0x1b,0x35},
	{0x1b,0x3b},
	{0x1b,0x3c},
	{0x1b,0x37},
	{0x1b,0x3d},
	{0x1b,0x3d},
	{0x1b,0x3e},
	{0x1b,0x40},
	{0x1b,0x40},
	{0x1b,0x3f},
	{0x1b,0x41},
	{0x1b,0x42},
	{0x1b,0x48},
	{0x1b,0x44},
	{0x1b,0x50},
	{0x1b,0x43},
	{0x1b,0x4a},
	{0x1b,0x51},
	{0x1b,0x60},
	{0x1b,0x53},
	{0x1b,0x61},
	{0x1b,0x5a},
	{0x1b,0x68},
	{0x1b,0x55},
	{0x1b,0x70},
	{0x1b,0x64},
	{0x1b,0x6a},
	{0x1b,0x65},
	{0x1b,0x78},
	{0x1b,0x66},
	{0x1b,0x5f},
	{0x1b,0x74},
	{0x1b,0x6e},
	{0x1b,0x75},
	{0x1b,0x7d},
	{0x1b,0x7c},
	{0x1b,0x6f},
	{0x1b,0x77},
	{0x1b,0x7e},
	{0x1b,0x81},
	{0x1b,0x88},
	{0x1b,0x88},
	{0x1b,0x83},
	{0x1b,0x83},
	{0x1b,0x89},
	{0x1b,0x8a},
	{0x1b,0x91},
	{0x1b,0x98},
	{0x1b,0x86},
	{0x1b,0x8c},
	{0x1b,0x99},
	{0x1b,0x8d},
	{0x1b,0x8e},
	{0x1b,0x95},
	{0x1b,0xa9},
	{0x1b,0xaa},
	{0x1b,0x97},
	{0x1b,0xa5},
	{0x1b,0xb2},
	{0x1b,0xb9},
	{0x1b,0xb3},
	{0x1b,0xba},
	{0x1b,0xae},
	{0x1b,0xb5},
	{0x1b,0xb6},
	{0x1b,0xaf},
	{0x1b,0xb7},
	{0x1b,0xbd},
	{0x1b,0xbe},
	{0x1b,0xc0},
	{0x1b,0xbf},
	{0x1b,0xc1},
	{0x1b,0xc2},
	{0x1b,0xc8},
	{0x1b,0xc9},
	{0x1b,0xd0},
	{0x1b,0xca},
	{0x1b,0xc5},
	{0x1b,0xd2},
	{0x1b,0xcc},
	{0x1b,0xd9},
	{0x1b,0xe1},
	{0x1b,0xe2},
	{0x1b,0xd5},
	{0x1b,0xdb},
	{0x1b,0xe9},
	{0x1b,0xf1},
	{0x1b,0xdd},
	{0x1b,0xf2},
	{0x1b,0xf9},
	{0x1c,0x01},
	{0x1c,0x02},
	{0x1b,0xee},
	{0x1c,0x10},
	{0x1c,0x09},
	{0x1c,0x0a},
	{0x1b,0xfd},
	{0x1c,0x0b},
	{0x1c,0x0c},
	{0x1c,0x19},
	{0x1c,0x1a},
	{0x1c,0x28},
	{0x1c,0x30},
	{0x1c,0x1c},
	{0x1c,0x16},
	{0x1c,0x31},
	{0x1c,0x32},
	{0x1c,0x2c},
	{0x1c,0x33},
	{0x1c,0x3a},
	{0x1c,0x2d},
	{0x1c,0x2e},
	{0x1c,0x3c},
	{0x1c,0x2f},
	{0x1c,0x3d},
	{0x1c,0x37},
	{0x1c,0x3e},
	{0x1c,0x40},
	{0x1c,0x3f},
	{0x1c,0x41},
	{0x1c,0x48},
	{0x1c,0x42},
	{0x1c,0x49},
	{0x1c,0x43},
	{0x1c,0x4a},
	{0x1c,0x58},
	{0x1c,0x46},
	{0x1c,0x4c},
	{0x1c,0x59},
	{0x1c,0x68},
	{0x1c,0x4e},
	{0x1c,0x56},
	{0x1c,0x69},
	{0x1c,0x71},
	{0x1c,0x72},
	{0x1c,0x6c},
	{0x1c,0x79},
	{0x1c,0x7a},
	{0x1c,0x6d},
	{0x1c,0x7b},
	{0x1c,0x7c},
	{0x1c,0x6f},
	{0x1c,0x80},
	{0x1c,0x7e},
	{0x1c,0x81},
	{0x1c,0x88},
	{0x1c,0x7f},
	{0x1c,0x90},
	{0x1c,0x89},
	{0x1c,0x91},
	{0x1c,0x98},
	{0x1c,0x8c},
	{0x1c,0xa1},
	{0x1c,0xa8},
	{0x1c,0xa2},
	{0x1c,0x95},
	{0x1c,0xa3},
	{0x1c,0xaa},
	{0x1c,0xb8},
	{0x1c,0xa5},
	{0x1c,0xb9},
	{0x1c,0x9f},
	{0x1c,0xa7},
	{0x1c,0xae},
	{0x1c,0xbc},
	{0x1c,0xb6},
	{0x1c,0xb7},
	{0x1c,0xbd},
	{0x1c,0xbe},
	{0x1c,0xbf},
	{0x1c,0xc1},
	{0x1c,0xc2},
	{0x1c,0xd0},
	{0x1c,0xc3},
	{0x1c,0xc4},
	{0x1c,0xd1},
	{0x1c,0xc6},
	{0x1c,0xcc},
	{0x1c,0xe1},
	{0x1c,0xcd},
	{0x1c,0xce},
	{0x1c,0xe9},
	{0x1c,0xea},
	{0x1c,0xf1},
	{0x1c,0xde},
	{0x1c,0xf3},
	{0x1c,0xf4},
	{0x1c,0xee},
	{0x1c,0xf5},
	{0x1c,0xfc},
	{0x1c,0xef},
	{0x1c,0xf7},
	{0x1d,0x02},
	{0x1d,0x08},
	{0x1d,0x09},
	{0x1d,0x04},
	{0x1d,0x11},
	{0x1d,0x05},
	{0x1d,0x06},
	{0x1d,0x13},
	{0x1d,0x28},
	{0x1d,0x15},
	{0x1d,0x16},
	{0x1d,0x38},
	{0x1d,0x1d},
	{0x1d,0x1e},
	{0x1d,0x33},
	{0x1d,0x2d},
	{0x1d,0x2e},
	{0x1d,0x3c},
	{0x1d,0x36},
	{0x1d,0x3d},
	{0x1d,0x37},
	{0x1d,0x40},
	{0x1d,0x3f},
	{0x1d,0x41},
	{0x1d,0x42},
	{0x1d,0x50},
	{0x1d,0x43},
	{0x1d,0x4a},
	{0x1d,0x45},
	{0x1d,0x46},
	{0x1d,0x59},
	{0x1d,0x4d},
	{0x1d,0x4e},
	{0x1d,0x5b},
	{0x1d,0x4f},
	{0x1d,0x57},
	{0x1d,0x5e},
	{0x1d,0x79},
	{0x1d,0x7a},
	{0x1d,0x6e},
	{0x1d,0x7b},
	{0x1d,0x76},
	{0x1d,0x77},
	{0x1d,0x7e},
	{0x1d,0x88},
	{0x1d,0xa8},
	{0x1d,0x89},
	{0x1d,0x8a},
	{0x1d,0xa5},
	{0x1d,0x8b},
	{0x1d,0x99},
	{0x1d,0xad},
	{0x1d,0x8e},
	{0x1d,0x9b},
	{0x1d,0x8f},
	{0x1d,0x9d},
	{0x1d,0x9e},
	{0x1d,0xc0},
	{0x1d,0xbf},
	{0x1d,0xc1},
	{0x1d,0xc8},
	{0x1d,0xc3},
	{0x1d,0xca},
	{0x1d,0xc5},
	{0x1d,0xe0},
	{0x1d,0xd9},
	{0x1d,0xce},
	{0x1d,0xe8},
	{0x1d,0xcf},
	{0x1d,0xdd},
	{0x1d,0xe5},
	{0x1d,0xde},
	{0x1d,0xf3},
	{0x1d,0xed},
	{0x1d,0xf5},
	{0x1e,0x02},
	{0x1e,0x08},
	{0x1e,0x04},
	{0x1e,0x05},
	{0x1d,0xff},
	{0x1e,0x20},
	{0x1e,0x0d},
	{0x1e,0x0e},
	{0x1e,0x0f},
	{0x1e,0x23},
	{0x1e,0x17},
	{0x1e,0x25},
	{0x1e,0x26},
	{0x1e,0x1f},
	{0x1e,0x2e},
	{0x1e,0x3b},
	{0x1e,0x36},
	{0x1e,0x37},
	{0x1e,0x3e},
	{0x1e,0x40},
	{0x1e,0x41},
	{0x1e,0x42},
	{0x1e,0x43},
	{0x1e,0x44},
	{0x1e,0x4a},
	{0x1e,0x46},
	{0x1e,0x47},
	{0x1e,0x53},
	{0x1e,0x68},
	{0x1e,0x4f},
	{0x1e,0x6a},
	{0x1e,0x71},
	{0x1e,0x66},
	{0x1e,0x5f},
	{0x1e,0x67},
	{0x1e,0x75},
	{0x1e,0x6f},
	{0x1e,0x7d},
	{0x1e,0x7e},
	{0x1e,0x81},
	{0x1e,0x88},
	{0x1e,0x89},
	{0x1e,0x8a},
	{0x1e,0x98},
	{0x1e,0x8b},
	{0x1e,0x8d},
	{0x1e,0xa8},
	{0x1e,0x95},
	{0x1e,0x8f},
	{0x1e,0x97},
	{0x1e,0xac},
	{0x1e,0x9f},
	{0x1e,0xa7},
	{0x1e,0xaf},
	{0x1e,0xbc},
	{0x1e,0xb7},
	{0x1e,0xbe},
	{0x1e,0xbf},
	{0x1e,0xc8},
	{0x1e,0xc8},
	{0x1e,0xc9},
	{0x1e,0xca},
	{0x1e,0xc5},
	{0x1e,0xe0},
	{0x1e,0xd3},
	{0x1e,0xce},
	{0x1e,0xdc},
	{0x1e,0xea},
	{0x1e,0xd7},
	{0x1e,0xdf},
	{0x1e,0xed},
	{0x1e,0xee},
	{0x1e,0xef},
	{0x1f,0x08},
	{0x1f,0x02},
	{0x1f,0x03},
	{0x1e,0xff},
	{0x1f,0x0b},
	{0x1f,0x14},
	{0x1f,0x07},
	{0x1f,0x15},
	{0x1f,0x24},
	{0x1f,0x17},
	{0x1f,0x1e},
	{0x1f,0x26},
	{0x1f,0x2d},
	{0x1f,0x3b},
	{0x1f,0x3c},
	{0x1f,0x3e},
	{0x1f,0x40},
	{0x1f,0x3f},
	{0x1f,0x42},
	{0x1f,0x50},
	{0x1f,0x49},
	{0x1f,0x45},
	{0x1f,0x52},
	{0x1f,0x53},
	{0x1f,0x68},
	{0x1f,0x5c},
	{0x1f,0x64},
	{0x1f,0x78},
	{0x1f,0x73},
	{0x1f,0x5f},
	{0x1f,0x6e},
	{0x1f,0x80},
	{0x1f,0x7d},
	{0x1f,0x81},
	{0x1f,0x7f},
	{0x1f,0x90},
	{0x1f,0x8a},
	{0x1f,0x86},
	{0x1f,0x93},
	{0x1f,0x87},
	{0x1f,0x95},
	{0x1f,0xaa},
	{0x1f,0x97},
	{0x1f,0xb3},
	{0x1f,0xad},
	{0x1f,0xb5},
	{0x1f,0xaf},
	{0x1f,0xbd},
	{0x1f,0xc0},
	{0x1f,0xbf},
	{0x1f,0xc2},
	{0x1f,0xc3},
	{0x1f,0xc5},
	{0x1f,0xd8},
	{0x1f,0xd3},
	{0x1f,0xe2},
	{0x1f,0xdb},
	{0x1f,0xea},
	{0x1f,0xe6},
	{0x1f,0xf9},
	{0x1f,0xed},
	{0x1f,0xfc},
	{0x1f,0xf7},
	{0x1f,0xfe},
	{0x1e,0x97},
	{0x1f,0xff},
};


uint8_t rtc_read_temp(uint8_t* temp)
{
	uint8_t time = 20;
	uint8_t buffer = 0;


	if(rtc_write_lock_on() != I2C_OK)
		return I2C_NO_ACK;
	
    buffer = 0x10;
    if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x17, &buffer, 1) != I2C_OK) 
		return I2C_NO_ACK;
	
	if(rtc_write_lock_off() != I2C_OK)
		return I2C_NO_ACK;
	
	while(time --)
	{
		HAL_Delay(1);
		
        rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x17, &buffer, 1);
		if (!(buffer & 0x20)) {
            rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x16, &buffer, 1);
            *temp = buffer;
            return I2C_OK;
        }
	}
	
	return I2C_NO_ACK;
}

uint8_t rtc_set_bat_charge(uint8_t mode)
{
	uint8_t buffer = 0;

	if(rtc_write_lock_on() != I2C_OK)
		return I2C_NO_ACK;
		
	if (mode == 0) { 
		buffer = 0x00; 
	} else {
		buffer = 0x82;
	}
    if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x18, &buffer, 1) != I2C_OK) 
		return I2C_NO_ACK;
	
	if(rtc_write_lock_off() != I2C_OK)
		return I2C_NO_ACK;
	
	return I2C_OK;
}

float system_get_rtc_temp(void)//已改1208
{
	float tempSum = 0;
	uint8_t count = 0;
	uint16_t readTemp;
	int quick;
	int i;

	for (i = 0; i < 5; i++) {
		if (wave1006_read_temp_adc(&readTemp) > 0) {
			quick = readTemp;
			count++;
			tempSum += quick;
		}
		HAL_Delay(5);
	}
	if (count == 0) {
		tempSum = -300;
	} else {
		tempSum = tempSum / count;
	}
	return tempSum;
}


uint8_t rtc_read_vbat(int* vbat)
{
	uint8_t time = 20;
	uint8_t buffer[2] = {0};
    int value = 0;
    *vbat = 0;

	if(rtc_write_lock_on() != I2C_OK)
		return I2C_NO_ACK;
	
    buffer[0] = 0x10;
    if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x19, buffer, 1) != I2C_OK) 
		return I2C_NO_ACK;
	
	if(rtc_write_lock_off() != I2C_OK)
		return I2C_NO_ACK;
	
	while (time --)
	{
		HAL_Delay(1);
		
        rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x17, buffer, 1);
		if (!(buffer[0] & 0x20)) {
            rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x1A, buffer, 2);
            value = buffer[0] & 0x80;
            value = (value << 1) + buffer[1];
            *vbat = value;
            return I2C_OK;
        }
	}
	
	return I2C_NO_ACK;

}
uint8_t rtc_read_date(RealTime* psRTC)
{
    uint8_t buffer[7] = {0};
    
    if (rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x00, buffer, 7)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
    psRTC->sec = (buffer[0] / 16) * 10 + (buffer[0] % 16);
    psRTC->min = (buffer[1] / 16) * 10 + (buffer[1] % 16);
    if (buffer[2] & 0x80) {//
        buffer[2] = buffer[2] & 0x7f;
        psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16);
    } else {
        if (buffer[2] & 0x20) {//
            buffer[2] = buffer[2] & 0x1f;
            psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16) + 12;
        } else {//
            buffer[2] = buffer[2] & 0x1f;
            psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16);
        }
    }
    // psRTC->week = (buffer[3] / 16) * 10 + (buffer[3] % 16);
    psRTC->day = (buffer[4] / 16) * 10 + (buffer[4] % 16);
    psRTC->mon = (buffer[5] / 16) * 10 + (buffer[5] % 16);
    psRTC->year = (buffer[6] / 16) * 10 + (buffer[6] % 16);
    return I2C_OK;
}

uint8_t rtc_write_date(RealTime* setRTC)	
{                               
    uint8_t buffer[7] = {0};
    rtc_write_lock_on();
    buffer[0] = (setRTC->sec / 10) * 16 + (setRTC->sec % 10);
    buffer[1] = (setRTC->min / 10) * 16 + (setRTC->min % 10);
    buffer[2] = (setRTC->hour / 10) * 16 + (setRTC->hour % 10) + 0x80;//
    buffer[3] = 0;
    buffer[4] = (setRTC->day / 10) * 16 + (setRTC->day % 10);
    buffer[5] = (setRTC->mon / 10) * 16 + (setRTC->mon % 10);
    buffer[6] = (setRTC->year / 10) * 16 + (setRTC->year % 10);
    if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x00, buffer, 7)!= I2C_OK) {
        rtc_write_lock_off();
        return I2C_NO_ACK;
    } 
    rtc_write_lock_off();
    return I2C_OK;
}

void PrintfTime(RealTime* rtc)
{
	// UsbPrintf("\n20%d/%d/%d %d:%d:%d\n", rtc->year, rtc->mon, rtc->day, rtc->hour, rtc->min, rtc->sec);
}



uint8_t rtc_out_4096(void)
{
    uint8_t buffer[2] = {0x21, 0x42};
	if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x10, buffer, 2)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
	return I2C_OK;
}

uint8_t rtc_disable_int(void)
{
    uint8_t buffer[2] = {0x00, 0x40};
	if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x10, buffer, 2)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
	return I2C_OK;
}

uint8_t rtc_set_testcap(uint8_t *p_dat)
{	
	// osc_buf[0] = ((cap & 0xff) << 3) | (cap & 0x07);
	// osc_buf[1] = ((mode & 0x03) << 3) | ((cap & 0xff) >> 5);	
	if (rtc_write_multi_bytes(RTC_3900_ADDRESS, WAVE1006_REG_USER_RAM_START + 21, p_dat, 2)!= I2C_OK) {
		UsbPrintf("adjust cap iic error\n");
        return I2C_NO_ACK;
    } 
	return I2C_OK;
}

uint8_t rtc_set_testmode(void)
{
	// uint8_t config[9] = {0xFF, 0xFF, 0x2F, 0xFF, 0x30, 0x30, 0xFE, 0x22, 0x80};
		
    // rtc_write_lock_on();
	
	// if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x3F, config, 9)!= I2C_OK) {
    //     rtc_write_lock_off();
    //     return I2C_NO_ACK;
    // } 
    // rtc_write_lock_off();
	return I2C_OK;
}

uint8_t rtc_1006_set_testmode(uint8_t channel)
{
	uint8_t buf;
	uint8_t osc_buf[2] = {0};

	rtc_set_channel(channel, RTC_INIT_1006);
	buf = 0x40;
	if(drv_wave1006_write_reg(DEV_SD8804, WAVE1006_REG_CTR3, 1, &buf) != WAVE1006_EXIT_OK)   //如果是有应该先关闭32K输出(默认为关闭SD3068的32K)
	{
		return I2C_NO_ACK;
	}
	//选择为SD3031封装(必须在进测试模式之前选择，否则芯片pad改变)
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)   //回读ram21
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x0f;
	buf |= 0x0c;//根据pad配置表，编号12为3031
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)//写入部分ram21寄存器
	{
		return I2C_NO_ACK;
	}
	if (wave1006_enter_test_mode(WAVE1006_TEST_PAD | WAVE1006_TEST_OSC | WAVE1006_TEST_ADC) != WAVE1006_EXIT_OK)   //此处一定要注意，没进入测试模式也需要将I0切换掉，或者不能继续运行程序
	{
		return I2C_NO_ACK;
	}
	// UsbPrintf("pad change OK\n");
	HAL_Delay(5);
	rtc_set_channel(channel, RTC_SD3031);
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK) 
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x38;   //清0 RuleTempAdj[2:0]      //ADC尺子 暂选7
	buf |=  0x28;
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK)
	{
		return I2C_NO_ACK;
	}

	//1、配置好OSC TEST参数     RAM24、RAM25
	if (drv_wave1006_read_reg(DEV_SD8804, WAVE1006_REG_USER_RAM_START + 24, 1, &osc_buf[1]) != WAVE1006_EXIT_OK)  //读ram25   
	{
		return I2C_NO_ACK;
	}
	osc_buf[0]  = 0xf7;   //ram24
	osc_buf[1] &= ~0x1f;
	osc_buf[1] |= 0x19;		//ram25
	if (drv_wave1006_write_reg(DEV_SD8804, WAVE1006_REG_USER_RAM_START + 23, 2, osc_buf) != WAVE1006_EXIT_OK)    //写ram24、ram25
	{
		return I2C_NO_ACK;
	}
	// UsbPrintf("i2c OK after pad change \n");
	
	return I2C_OK;
}

uint8_t rtc_8800_adc_testmode(uint8_t channel)
{
	uint8_t buf;

	rtc_set_channel(channel, RTC_INIT_1006);
	buf = 0x40;
	if(drv_wave1006_write_reg(DEV_SD8804, WAVE1006_REG_CTR3, 1, &buf) != WAVE1006_EXIT_OK)   //如果是有应该先关闭32K输出(默认为关闭SD3068的32K)
	{
		return I2C_NO_ACK;
	}
	//选择为SD3031封装(必须在进测试模式之前选择，否则芯片pad改变)
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)   //回读ram21
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x0f;
	buf |= 0x0c;//根据pad配置表，编号12为3031
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)//写入部分ram21寄存器
	{
		return I2C_NO_ACK;
	}
	if (wave1006_enter_test_mode(WAVE1006_TEST_PAD | WAVE1006_TEST_ADC) != WAVE1006_EXIT_OK)   //此处一定要注意，没进入测试模式也需要将I0切换掉，或者不能继续运行程序
	{
		return I2C_NO_ACK;
	}
	HAL_Delay(5);
	rtc_set_channel(channel, RTC_SD3031);
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK) 
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x38;   //清0 RuleTempAdj[2:0]      //ADC尺子 暂选5
	buf |=  0x28;
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK)
	{
		return I2C_NO_ACK;
	}
	
	return I2C_OK;
}

uint8_t rtc_1006_exit_testmode(uint8_t channel)
{
	uint8_t buf = 0x00;
		
	rtc_set_channel(channel, RTC_SD3031);
	buf = 0x00;
	if (rtc_write_multi_bytes(RTC_3900_ADDRESS, WAVE1006_REG_EXTEND , &buf, 1) != I2C_OK) {
		rtc_set_channel(channel, RTC_INIT_1006);
		return I2C_NO_ACK;
	} 
	rtc_set_channel(channel, RTC_INIT_1006);
	UsbPrintf("exit testmode success\n");
	return I2C_OK;
}

uint8_t rtc_exit_testmode(void)
{
	uint8_t config = 0x00;
		
    rtc_write_lock_on();
	
	if (rtc_write_multi_bytes(RTC_3900_ADDRESS, 0x47, &config, 1)!= I2C_OK) {
        rtc_write_lock_off();
        return I2C_NO_ACK;
    } 
    rtc_write_lock_off();
	
	return I2C_OK;
}


uint8_t rtc_read_otp(void)
{
	memset(g_otpBuffer, 0xff, OTP_LENGTH_SD3900);
    if (rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x72, g_otpBuffer, OTP_LENGTH_SD3900)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
    return I2C_OK;
}

uint8_t* get_rtc_otp(void)
{
    return g_otpBuffer;
}

void rtc_set_int_channel(uint8_t channel)
{
    // uint8_t intChannel;
    // HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1 | GPIO_PIN_3 | GPIO_PIN_5 | GPIO_PIN_7 | 
	// 						GPIO_PIN_9| GPIO_PIN_11, GPIO_PIN_SET);
    // intChannel = (channel - 1) / 14;
    // HAL_GPIO_WritePin(GPIOE, GPIO_PIN_0, intChannel & 0x01);
    // HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, intChannel & 0x02);
    // HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, intChannel & 0x04);
    // HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);
}

uint8_t rtc_read_otp_data(uint8_t* buffer, uint16_t startAddress, uint16_t length)
{
    int i;
    if (startAddress < 0x72) { return I2C_START_FAIL; }
	memset(g_otpBuffer, 0xff, OTP_LENGTH_SD3900);
    if (rtc_read_multi_bytes(RTC_3900_ADDRESS, 0x72, g_otpBuffer, startAddress - 0x72 + length) != I2C_OK) {
        return I2C_NO_ACK;
    } 
    for (i = 0; i < length; i++) {
        buffer[i] = g_otpBuffer[startAddress - 0x72 + i];
    }
    return I2C_OK;
}

uint8_t rtc_convert_temp_offset(float rtc_adc, float system_temp)
{
	uint8_t offset;
	offset = (uint8_t)(((rtc_adc - (system_temp + 60) * 2)) * 2 - 48);//详见芯片设计手册，起始-60度，地址为0x30;每1bitADC，对应2位otp；每1℃对应2bitADC；
	return offset;
}

uint8_t rtc_write_otp_config(void)
{
    uint8_t config[16]=	{0xBC, 0xEB, 0xFF, 0xFF, 0x2F, 0xFF, 0xFF, 0xFE, 0x22, 0xFF, 0x00, 0x00, 0xFF, 0x02, 0xDC, 0x4A};
    // uint8_t config[16]=	{0xBC, 0xEF, 0xFF, 0xFF, 0x2F, 0xFF, 0xFF, 0xFE, 0x22, 0xFF, 0x00, 0x00, 0xFF, 0x02, 0xDC, 0x4A};
    uint8_t i2c_result;
    i2c_result = rtc_download_otp_data(config, 0x162, 16);//0x162 is config0 address
    return i2c_result;
} 


uint16_t rtc_init_test_cap(float temp)
{
	uint16_t cap = 800;
	if (temp > -45 && temp <= -35)		//-40
	{
		cap = 256;
	}
	else if (temp > -15 && temp <= -5)	//-10
	{
		cap = 486;
	}
	else if (temp > 10 && temp <= 35)		//29
	{
		cap = 586;
	}
	else if (temp > 55 && temp <= 65)		//60
	{
		cap = 486;
	}
	else if (temp > 80 && temp <= 90)		//85
	{
		cap = 256;
	}
	return cap;
}
/*
OSCCapSel<12:11>	"振荡器引脚OSCIN和OSCOUT粗调电容选择项。
00:0pF
01:1.5pF
10:3.0pF
11:4.5pF"	
OSCCapSel<10:6>	"振荡器引脚OSCIN和OSCOUT次级粗调电容选择项。步进为408fF"
OSCCapSel<5:3>	"振荡器引脚OSCIN细调电容选择项。步进为51fF"
OSCCapSel<2:0>	"振荡器引脚OSCOUT细调电容选择项。步进为51fF"	
*/
float cap_uint_to_float(uint8_t cap1, uint8_t cap2)
{
	float convert = 0;
	uint16_t cap_config = 0;
	cap_config = ((cap2 & 0x07) << 5) | (cap1 >> 3);
	convert = 1.5 * ((cap2 >> 3) & 0x03) + cap_config * 0.051;
	return convert;
}

float cap_config_to_float(uint8_t mode, uint8_t cap)
{
	float convert = 0;
	convert = 1.5 * mode + cap * 0.051;
	return convert;
}

void cap_config_to_uint(uint8_t mode, uint8_t cap, uint8_t* cap_buf)
{
	cap_buf[0] = ((cap & 0xff) << 3) | (cap & 0x07);
	cap_buf[1] = ((mode & 0x03) << 3) | ((cap & 0xff) >> 5);
}

void cap_list_to_uint(uint16_t number, uint8_t* cap_buf)
{
	if (number <= SD8800_CAP_LIST_MAX) {
		cap_buf[1] = g_capList[number][0];
		cap_buf[0] = g_capList[number][1];
	}
}

void cap_float_to_uint(float f_cap, uint8_t *p_dat1, uint8_t *p_dat2)
{
	float convert;
	uint16_t cap_config = 0;
	convert = f_cap - SD8800_CAP_MIN;//固定大电容
	cap_config = convert / 0.051;//矩阵小电容

	// if (cap_config > 0 && (cap_config + 1) % 32 == 0) {
	// 	cap_config -= 1;
	// } 
	*p_dat2 = (SD8800_CAP_MODE << 3) | ((cap_config & 0xff) >> 5);
	*p_dat1 = ((cap_config & 0xff) << 3) | (cap_config & 0x07);

}

uint16_t cap_list_number_convert(uint16_t start, float ppm)
{
	float sum2d4 = 2.4 * CAP_STEP_2D4;
	float sum1d2 = 1.2 * (CAP_STEP_1D2 - CAP_STEP_2D4);
	float sum0d8 = 0.8 * (CAP_STEP_0D8 - CAP_STEP_1D2);
	float sum0d6 = 0.6 * (CAP_STEP_0D6 - CAP_STEP_0D8);
	float sum0d4 = 0.4 * (start - CAP_STEP_0D6);
	uint16_t number = 1;
	if (ppm < sum0d4) {
		number = start - ppm * 2.5;
	} else {
		ppm -= sum0d4;
		if (ppm < sum0d6) {
			number = CAP_STEP_0D6 - ppm / 0.6;
		} else {
			ppm -= sum0d6;
			if (ppm < sum0d8) {
				number = CAP_STEP_0D8 - ppm / 0.8;
			} else {
				ppm -= sum0d8;
				if (ppm < sum1d2) {
					number = CAP_STEP_1D2 - ppm / 1.2;
				} else {
					ppm -= sum1d2;
					if (ppm < sum2d4) {
						number = CAP_STEP_2D4 - ppm / 2.4;
					} else {
						number = 1;
					}
				}
			}
		}
	}
	return number;
}

int digtal_adj_convert(uint16_t start, float ppm)
{
	float sum;
	int digtal = 0;
	
	sum =  2.4 * (CAP_STEP_2D4 - 1) + 1.2 * (CAP_STEP_1D2 - CAP_STEP_2D4) + 0.8 * (CAP_STEP_0D8 - CAP_STEP_1D2)
			+ 0.6 * (CAP_STEP_0D6 - CAP_STEP_0D8) + 0.4 * (start - CAP_STEP_0D6);
	if (ppm < sum) {
		return 0;
	} else {
		digtal = sum - ppm;
		if (digtal < -189) {//数字补偿只有6bit，最大值为63，对应的数为-189
			digtal = -189;
		}
		return digtal;
	}
}

uint8_t wave1006_read_temp_adc(uint16_t* temp)
{
	uint8_t buffer[2] = {0};
	buffer[0] = 0x10;
	uint8_t i;
	if (drv_wave1006_write_reg(DEV_SD3068, 0x17, 1, &buffer[0]) != WAVE1006_EXIT_OK) {
		return 0;
	}
	for (i = 0; i < 10; i++) {
		HAL_Delay(1);
		drv_wave1006_read_reg(DEV_SD3068, 0x17, 1, buffer);
		if ((buffer[0] & 0x30) == 0) {
			break;
		}
	}
	if (i >= 10) {return 0;}
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 26, 2, buffer) != WAVE1006_EXIT_OK)  //读ram26、ram27  
	{
		return 0;
	}
	*temp = buffer[0];
	if (buffer[1] & 0x40) {
		*temp += 256;
	}
	return 1;
}
