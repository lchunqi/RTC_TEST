#include "main.h"
#include "rtc.h"
#include <string.h>
#include "drv_wave1006.h"

#define OTP_LENGTH_SD3900           1024
uint8_t g_otpBuffer[OTP_LENGTH_SD3900] = {0xff};
#define CAP_STEP_3D6			1
#define CAP_STEP_2D4			1
#define CAP_STEP_1D2			21
#define CAP_STEP_0D8			41
#define CAP_STEP_0D6			102
#define CAP_STEP_0D4			SD8800_CAP_LIST_MAX

uint8_t g_capList[SD8800_CAP_LIST_MAX + 1][2] = {
	{0x10,0x00},
	{0x10,0x01},
	{0x10,0x02},
	{0x10,0x03},
	{0x10,0x05},
	{0x10,0x06},
	{0x10,0x07},
	{0x10,0x12},
	{0x10,0x18},
	{0x10,0x0f},
	{0x10,0x1a},
	{0x10,0x17},
	{0x10,0x24},
	{0x10,0x25},
	{0x10,0x1f},
	{0x10,0x2c},
	{0x10,0x38},
	{0x10,0x39},
	{0x10,0x3a},
	{0x10,0x3b},
	{0x10,0x3d},
	{0x10,0x3e},
	{0x10,0x3f},
	{0x10,0x41},
	{0x10,0x42},
	{0x10,0x43},
	{0x10,0x48},
	{0x10,0x45},
	{0x10,0x4a},
	{0x10,0x47},
	{0x10,0x4c},
	{0x10,0x52},
	{0x10,0x53},
	{0x10,0x59},
	{0x10,0x61},
	{0x10,0x62},
	{0x10,0x5b},
	{0x10,0x64},
	{0x10,0x65},
	{0x10,0x66},
	{0x10,0x71},
	{0x10,0x72},
	{0x10,0x6d},
	{0x10,0x74},
	{0x10,0x79},
	{0x10,0x75},
	{0x10,0x76},
	{0x10,0x7b},
	{0x10,0x77},
	{0x10,0x80},
	{0x10,0x7d},
	{0x10,0x81},
	{0x10,0x82},
	{0x10,0x7f},
	{0x10,0x84},
	{0x10,0x89},
	{0x10,0x85},
	{0x10,0x86},
	{0x10,0x87},
	{0x10,0x8c},
	{0x10,0x92},
	{0x10,0x98},
	{0x10,0xa0},
	{0x10,0x99},
	{0x10,0xa1},
	{0x10,0xa2},
	{0x10,0x9b},
	{0x10,0xa4},
	{0x10,0x9d},
	{0x10,0xb0},
	{0x10,0xa6},
	{0x10,0xb1},
	{0x10,0xa7},
	{0x10,0xb8},
	{0x10,0xb3},
	{0x10,0xb9},
	{0x10,0xb5},
	{0x10,0xba},
	{0x10,0xbb},
	{0x10,0xb7},
	{0x10,0xbd},
	{0x10,0xbd},
	{0x10,0xc0},
	{0x10,0xbf},
	{0x10,0xc1},
	{0x10,0xc2},
	{0x10,0xc3},
	{0x10,0xc4},
	{0x10,0xc9},
	{0x10,0xd0},
	{0x10,0xc6},
	{0x10,0xcb},
	{0x10,0xd2},
	{0x10,0xd8},
	{0x10,0xce},
	{0x10,0xd5},
	{0x10,0xd6},
	{0x10,0xdb},
	{0x10,0xe3},
	{0x10,0xdd},
	{0x10,0xe5},
	{0x10,0xe6},
	{0x10,0xeb},
	{0x10,0xf2},
	{0x10,0xf8},
	{0x10,0xf3},
	{0x10,0xf4},
	{0x10,0xf9},
	{0x10,0xfa},
	{0x10,0xf6},
	{0x11,0x00},
	{0x10,0xfc},
	{0x10,0xf7},
	{0x10,0xfd},
	{0x11,0x02},
	{0x10,0xfe},
	{0x11,0x03},
	{0x11,0x04},
	{0x11,0x09},
	{0x11,0x10},
	{0x11,0x06},
	{0x11,0x11},
	{0x11,0x0b},
	{0x11,0x12},
	{0x11,0x18},
	{0x11,0x0d},
	{0x11,0x14},
	{0x11,0x19},
	{0x11,0x21},
	{0x11,0x1a},
	{0x11,0x22},
	{0x11,0x28},
	{0x11,0x23},
	{0x11,0x24},
	{0x11,0x30},
	{0x11,0x25},
	{0x11,0x26},
	{0x11,0x1f},
	{0x11,0x32},
	{0x11,0x38},
	{0x11,0x2d},
	{0x11,0x34},
	{0x11,0x2e},
	{0x11,0x3a},
	{0x11,0x2f},
	{0x11,0x36},
	{0x11,0x3c},
	{0x11,0x37},
	{0x11,0x3d},
	{0x11,0x3d},
	{0x11,0x3e},
	{0x11,0x40},
	{0x11,0x3f},
	{0x11,0x41},
	{0x11,0x41},
	{0x11,0x42},
	{0x11,0x48},
	{0x11,0x44},
	{0x11,0x49},
	{0x11,0x45},
	{0x11,0x46},
	{0x11,0x51},
	{0x11,0x4b},
	{0x11,0x52},
	{0x11,0x58},
	{0x11,0x53},
	{0x11,0x4e},
	{0x11,0x61},
	{0x11,0x62},
	{0x11,0x56},
	{0x11,0x5b},
	{0x11,0x57},
	{0x11,0x69},
	{0x11,0x6a},
	{0x11,0x5e},
	{0x11,0x71},
	{0x11,0x72},
	{0x11,0x78},
	{0x11,0x73},
	{0x11,0x79},
	{0x11,0x7a},
	{0x11,0x6f},
	{0x11,0x76},
	{0x11,0x7c},
	{0x11,0x80},
	{0x11,0x7d},
	{0x11,0x81},
	{0x11,0x7e},
	{0x11,0x82},
	{0x11,0x88},
	{0x11,0x84},
	{0x11,0x90},
	{0x11,0x85},
	{0x11,0x86},
	{0x11,0x91},
	{0x11,0x87},
	{0x11,0x98},
	{0x11,0x93},
	{0x11,0x8e},
	{0x11,0xa1},
	{0x11,0x8f},
	{0x11,0xa2},
	{0x11,0x9c},
	{0x11,0xa4},
	{0x11,0x9d},
	{0x11,0xaa},
	{0x11,0xa6},
	{0x11,0xb2},
	{0x11,0xb8},
	{0x11,0xb3},
	{0x11,0xb9},
	{0x11,0xae},
	{0x11,0xb5},
	{0x11,0xbb},
	{0x11,0xbc},
	{0x11,0xb7},
	{0x11,0xbd},
	{0x11,0xbe},
	{0x11,0xc0},
	{0x11,0xbf},
	{0x11,0xc1},
	{0x11,0xc2},
	{0x11,0xc8},
	{0x11,0xc3},
	{0x11,0xc9},
	{0x11,0xc5},
	{0x11,0xc6},
	{0x11,0xcb},
	{0x11,0xc7},
	{0x11,0xcd},
	{0x11,0xd4},
	{0x11,0xe1},
	{0x11,0xe2},
	{0x11,0xe8},
	{0x11,0xe3},
	{0x11,0xe9},
	{0x11,0xdd},
	{0x11,0xde},
	{0x11,0xf2},
	{0x11,0xf8},
	{0x11,0xf3},
	{0x11,0xf9},
	{0x11,0xfa},
	{0x11,0xf5},
	{0x11,0xf6},
	{0x11,0xfc},
	{0x11,0xf7},
	{0x12,0x03},
	{0x12,0x09},
	{0x11,0xff},
	{0x12,0x05},
	{0x12,0x0b},
	{0x12,0x07},
	{0x12,0x0d},
	{0x12,0x19},
	{0x12,0x1a},
	{0x12,0x0f},
	{0x12,0x1b},
	{0x12,0x17},
	{0x12,0x29},
	{0x12,0x2a},
	{0x12,0x26},
	{0x12,0x2c},
	{0x12,0x27},
	{0x12,0x39},
	{0x12,0x2e},
	{0x12,0x35},
	{0x12,0x3b},
	{0x12,0x3c},
	{0x12,0x37},
	{0x12,0x3d},
	{0x12,0x3e},
	{0x12,0x3f},
	{0x12,0x41},
	{0x12,0x42},
	{0x12,0x48},
	{0x12,0x43},
	{0x12,0x49},
	{0x12,0x45},
	{0x12,0x51},
	{0x12,0x4b},
	{0x12,0x60},
	{0x12,0x59},
	{0x12,0x5a},
	{0x12,0x68},
	{0x12,0x5b},
	{0x12,0x70},
	{0x12,0x6a},
	{0x12,0x5e},
	{0x12,0x78},
	{0x12,0x67},
	{0x12,0x6d},
	{0x12,0x7a},
	{0x12,0x75},
	{0x12,0x7c},
	{0x12,0x77},
	{0x12,0x7d},
	{0x12,0x7e},
	{0x12,0x82},
	{0x12,0x88},
	{0x12,0x84},
	{0x12,0x90},
	{0x12,0x8a},
	{0x12,0x86},
	{0x12,0x98},
	{0x12,0x8d},
	{0x12,0xa1},
	{0x12,0x95},
	{0x12,0x96},
	{0x12,0xb0},
	{0x12,0x97},
	{0x12,0xb1},
	{0x12,0xb8},
	{0x12,0x9f},
	{0x12,0xb9},
	{0x12,0xba},
	{0x12,0xb5},
	{0x12,0xbc},
	{0x12,0xb7},
	{0x12,0xbd},
	{0x12,0xc0},
	{0x12,0xbf},
	{0x12,0xc1},
	{0x12,0xc8},
	{0x12,0xc3},
	{0x12,0xd0},
	{0x12,0xc5},
	{0x12,0xc6},
	{0x12,0xe0},
	{0x12,0xd3},
	{0x12,0xce},
	{0x12,0xe8},
	{0x12,0xdb},
	{0x12,0xd7},
	{0x12,0xe5},
	{0x12,0xe6},
	{0x12,0xdf},
	{0x12,0xed},
	{0x12,0xfa},
	{0x12,0xf6},
	{0x13,0x01},
	{0x12,0xfd},
	{0x12,0xfe},
	{0x13,0x04},
	{0x13,0x0a},
	{0x13,0x0b},
	{0x13,0x20},
	{0x13,0x13},
	{0x13,0x0e},
	{0x13,0x28},
	{0x13,0x1c},
	{0x13,0x17},
	{0x13,0x31},
	{0x13,0x2b},
	{0x13,0x27},
	{0x13,0x3a},
	{0x13,0x35},
	{0x13,0x3c},
	{0x13,0x37},
	{0x13,0x3e},
	{0x13,0x40},
	{0x13,0x3f},
	{0x13,0x41},
	{0x13,0x48},
	{0x13,0x44},
	{0x13,0x4a},
	{0x13,0x46},
	{0x13,0x60},
	{0x13,0x59},
	{0x13,0x5a},
	{0x13,0x56},
	{0x13,0x70},
	{0x13,0x65},
	{0x13,0x66},
	{0x13,0x5f},
	{0x13,0x7a},
	{0x13,0x75},
	{0x13,0x6f},
	{0x13,0x77},
	{0x13,0x81},
	{0x13,0x82},
	{0x13,0x88},
	{0x13,0x90},
	{0x13,0x85},
	{0x13,0x92},
	{0x13,0x87},
	{0x13,0x9a},
	{0x13,0x95},
	{0x13,0xa3},
	{0x13,0x9d},
	{0x13,0xb2},
	{0x13,0xb3},
	{0x13,0xba},
	{0x13,0xb5},
	{0x13,0xb6},
	{0x13,0xb7},
	{0x13,0xbe},
	{0x13,0xbf},
	{0x13,0xc2},
	{0x13,0xc8},
	{0x13,0xc9},
	{0x13,0xd1},
	{0x13,0xd2},
	{0x13,0xd3},
	{0x13,0xda},
	{0x13,0xd5},
	{0x13,0xe4},
	{0x13,0xdd},
	{0x14,0x00},
	{0x13,0xe7},
	{0x14,0x08},
	{0x14,0x10},
	{0x14,0x0a},
	{0x14,0x18},
	{0x13,0xff},
	{0x14,0x1a},
	{0x14,0x15},
	{0x14,0x24},
	{0x14,0x25},
	{0x14,0x2c},
	{0x14,0x27},
	{0x14,0x2e},
	{0x14,0x3c},
	{0x14,0x3d},
	{0x14,0x3e},
	{0x14,0x40},
	{0x14,0x41},
	{0x14,0x48},
	{0x14,0x49},
	{0x14,0x51},
	{0x14,0x4c},
	{0x14,0x61},
	{0x14,0x68},
	{0x14,0x69},
	{0x14,0x57},
	{0x14,0x6c},
	{0x14,0x74},
	{0x14,0x75},
	{0x14,0x7c},
	{0x14,0x7d},
	{0x14,0x81},
	{0x14,0x90},
	{0x14,0x83},
	{0x14,0x91},
	{0x14,0xa0},
	{0x14,0x94},
	{0x14,0x95},
	{0x14,0xa3},
	{0x14,0x97},
	{0x14,0xac},
	{0x14,0xb4},
	{0x14,0xb5},
	{0x14,0xaf},
	{0x14,0xbd},
	{0x14,0xc0},
	{0x14,0xc1},
	{0x14,0xc2},
	{0x14,0xc9},
	{0x14,0xc5},
	{0x14,0xd9},
	{0x14,0xe2},
	{0x14,0xf0},
	{0x14,0xdd},
	{0x14,0xec},
	{0x14,0xdf},
	{0x14,0xfb},
	{0x15,0x00},
	{0x15,0x01},
	{0x15,0x10},
	{0x15,0x0a},
	{0x15,0x0b},
	{0x15,0x07},
	{0x15,0x0e},
	{0x15,0x16},
	{0x15,0x32},
	{0x15,0x39},
	{0x15,0x2d},
	{0x15,0x36},
	{0x15,0x3d},
	{0x15,0x40},
	{0x15,0x41},
	{0x15,0x42},
	{0x15,0x43},
	{0x15,0x45},
	{0x15,0x59},
	{0x15,0x62},
	{0x15,0x4f},
	{0x15,0x57},
	{0x15,0x79},
	{0x15,0x6e},
	{0x15,0x6f},
	{0x15,0x7e},
	{0x15,0x7f},
	{0x15,0x89},
	{0x15,0x85},
	{0x15,0x99},
	{0x15,0x8e},
	{0x15,0xa3},
	{0x15,0x9d},
	{0x15,0xb3},
	{0x15,0xae},
	{0x15,0xb6},
	{0x15,0xb7},
	{0x15,0xbf},
	{0x15,0xc2},
	{0x15,0xc3},
	{0x15,0xc5},
	{0x15,0xd3},
	{0x15,0xce},
	{0x15,0xcf},
	{0x15,0xe6},
	{0x15,0xdf},
	{0x15,0xfc},
	{0x15,0xf7},
	{0x16,0x18},
	{0x16,0x06},
	{0x16,0x22},
	{0x16,0x16},
	{0x16,0x25},
	{0x16,0x3a},
	{0x16,0x3b},
	{0x16,0x37},
	{0x16,0x40},
	{0x16,0x41},
	{0x16,0x50},
	{0x16,0x4a},
	{0x16,0x4c},
	{0x16,0x47},
	{0x16,0x56},
	{0x16,0x65},
	{0x16,0x7a},
	{0x16,0x76},
	{0x16,0x80},
	{0x16,0x7f},
	{0x16,0x89},
	{0x16,0x98},
	{0x16,0x93},
	{0x16,0x95},
	{0x16,0xb8},
	{0x16,0xb4},
	{0x16,0xae},
	{0x16,0xbd},
	{0x16,0xc0},
	{0x16,0xc8},
	{0x16,0xc4},
	{0x16,0xe0},
	{0x16,0xd3},
	{0x16,0xd5},
	{0x16,0xdd},
	{0x16,0xdf},
	{0x17,0x00},
	{0x17,0x02},
	{0x16,0xff},
	{0x17,0x0b},
	{0x17,0x22},
	{0x17,0x1c},
	{0x17,0x1e},
	{0x17,0x2d},
	{0x17,0x2f},
	{0x17,0x3e},
	{0x17,0x41},
	{0x17,0x50},
	{0x17,0x60},
	{0x17,0x5a},
	{0x17,0x56},
	{0x17,0x57},
	{0x17,0x67},
	{0x17,0x7d},
	{0x17,0x81},
	{0x17,0x89},
	{0x17,0x85},
	{0x17,0x87},
	{0x17,0x8f},
	{0x17,0x9e},
	{0x17,0xb5},
	{0x17,0xbd},
	{0x17,0xbf},
	{0x17,0xc2},
	{0x17,0xca},
	{0x17,0xe8},
	{0x17,0xdc},
	{0x17,0xeb},
	{0x17,0xf5},
	{0x17,0xfd},
	{0x17,0xff},

};


uint8_t rtc_read_temp(float* temp)//烧写完成以后的8825,分辨率0.5度
{
	uint8_t time = 20;
	uint8_t buffer[2] = {0};
	float quick = 0;

	*temp = 0;
	buffer[0] = 0x10;
    if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x57, buffer, 1) != I2C_OK) {
		return I2C_NO_ACK;
	}
	
	while(time --)
	{
        rtc_read_multi_bytes(RTC_8825_ADDRESS, 0x56, buffer, 2);
		if ((buffer[1] & 0x20) == 0) {
			quick = buffer[0] << 1;//read high 8bit
			if (buffer[1] & 0x40) {
				quick += 1;
			}
			if (quick > 400) {
				quick = (quick - 512) * 0.5;
			} else {
				quick = quick * 0.5;
			}
			*temp = quick;
            return I2C_OK;
        }
		HAL_Delay(1);
	}
	
	return I2C_NO_ACK;
}


float system_get_rtc_temp(void)//已改1208
{
	float tempSum = 0;
	uint8_t count = 0;
	uint16_t readTemp;
	int quick;
	int i;

	for (i = 0; i < 5; i++) {
		if (wave1006_read_temp_adc(&readTemp) > 0) {
			quick = readTemp;
			count++;
			tempSum += quick;
		}
		HAL_Delay(10);
	}
	if (count == 0) {
		tempSum = -300;
	} else {
		tempSum = tempSum / count;
	}
	return tempSum;
}

uint8_t rtc_read_date(RealTime* psRTC)
{
    uint8_t buffer[7] = {0};
    
    if (rtc_read_multi_bytes(RTC_8825_ADDRESS, 0x00, buffer, 7)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
    psRTC->sec = (buffer[0] / 16) * 10 + (buffer[0] % 16);
    psRTC->min = (buffer[1] / 16) * 10 + (buffer[1] % 16);
    if (buffer[2] & 0x80) {//
        buffer[2] = buffer[2] & 0x7f;
        psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16);
    } else {
        if (buffer[2] & 0x20) {//
            buffer[2] = buffer[2] & 0x1f;
            psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16) + 12;
        } else {//
            buffer[2] = buffer[2] & 0x1f;
            psRTC->hour = (buffer[2] / 16) * 10 + (buffer[2] % 16);
        }
    }
    // psRTC->week = (buffer[3] / 16) * 10 + (buffer[3] % 16);
    psRTC->day = (buffer[4] / 16) * 10 + (buffer[4] % 16);
    psRTC->mon = (buffer[5] / 16) * 10 + (buffer[5] % 16);
    psRTC->year = (buffer[6] / 16) * 10 + (buffer[6] % 16);
    return I2C_OK;
}

uint8_t rtc_write_date(RealTime* setRTC)	
{                               
    uint8_t buffer[7] = {0};
    buffer[0] = (setRTC->sec / 10) * 16 + (setRTC->sec % 10);
    buffer[1] = (setRTC->min / 10) * 16 + (setRTC->min % 10);
    buffer[2] = (setRTC->hour / 10) * 16 + (setRTC->hour % 10) + 0x80;//
    buffer[3] = 0;
    buffer[4] = (setRTC->day / 10) * 16 + (setRTC->day % 10);
    buffer[5] = (setRTC->mon / 10) * 16 + (setRTC->mon % 10);
    buffer[6] = (setRTC->year / 10) * 16 + (setRTC->year % 10);
    if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x00, buffer, 7)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
    return I2C_OK;
}

void PrintfTime(RealTime* rtc)
{
	// UsbPrintf("\n20%d/%d/%d %d:%d:%d\n", rtc->year, rtc->mon, rtc->day, rtc->hour, rtc->min, rtc->sec);
}



uint8_t rtc_out_freq(void)
{
	uint8_t buffer[2] = {0x21, 0x44};
	if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x10, buffer, 2)!= I2C_OK) {
        return I2C_NO_ACK;
    } 
	
	UsbPrintf("out 64Hz ...\n");
	return I2C_OK;
}

uint8_t rtc_disable_int(void)
{
    uint8_t buffer[2] = {0x00, 0x40};
	uint8_t i;
	for (i = 0; i < 10; i++) {
		if (check_sda_level()) {
			if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x10, buffer, 2) == I2C_OK) {
				UsbPrintf("close 64Hz ...\n");
				return I2C_OK;
			}
		}
		HAL_Delay(2);
	}
	UsbPrintf("close int error\n");
	return I2C_NO_ACK;
}


uint8_t rtc_set_testcap(uint8_t *p_dat)
{	
	uint8_t i;
	for (i = 0; i < 10; i++) {
		if (check_sda_level()) {
			if (rtc_write_multi_bytes(RTC_8825_ADDRESS, WAVE1006_REG_USER_RAM_START + 21, p_dat, 2) == I2C_OK) {
				return I2C_OK;
			} 
		}
		HAL_Delay(2);
	}
	UsbPrintf("adjust cap iic error\n");
	return I2C_NO_ACK;
}


uint8_t rtc_1006_set_testmode(uint8_t channel)
{
	uint8_t buf;
	uint8_t osc_buf[2] = {0};

	rtc_set_channel(channel, RTC_SD8825);
    HAL_Delay(5);
	buf = 0x40;
	if(drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_CTR3, 1, &buf) != WAVE1006_EXIT_OK)   //如果是有应该先关闭32K输出(默认为关闭SD3068的32K)
	{
		return I2C_NO_ACK;
	}
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK) 
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x38;   //清0 RuleTempAdj[2:0]      //ADC尺子 5
	buf |=  0x28;
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK)
	{
		return I2C_NO_ACK;
	}

	//1、配置好OSC TEST参数     RAM24、RAM25
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 24, 1, &osc_buf[1]) != WAVE1006_EXIT_OK)  //读ram25   
	{
		return I2C_NO_ACK;
	}
	osc_buf[0]  = 0xf7;   //ram24
	osc_buf[1] &= ~0x1f;
	osc_buf[1] |= 0x19;		//ram25
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 23, 2, osc_buf) != WAVE1006_EXIT_OK)    //写ram24、ram25
	{
		return I2C_NO_ACK;
	}
	//选择为SD8825封装(必须在进测试模式之前选择，否则芯片pad改变)
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)   //回读ram21
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x0f;
	buf |= 0x00;//根据pad配置表，编号0为8825
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)//写入部分ram21寄存器
	{
		return I2C_NO_ACK;
	}
	if (wave1006_enter_test_mode(WAVE1006_TEST_PAD | WAVE1006_TEST_OSC | WAVE1006_TEST_ADC) != WAVE1006_EXIT_OK)   //此处一定要注意，没进入测试模式也需要将I0切换掉，或者不能继续运行程序
	{
		return I2C_NO_ACK;
	}
	HAL_Delay(5);
	// rtc_set_channel(channel, RTC_SD8825);
	if (drv_wave1006_read_reg(DEV_SD3068, 0xFD, 1, &buf) != WAVE1006_EXIT_OK) {
		return I2C_NO_ACK;
	}
	UsbPrintf("test flag 0x%02X, mode %d\n", buf, (buf >> 3) & 0x01);
	UsbPrintf("i2c OK after pad change \n");
	log_printf("i2c OK after pad change \n");
	
	return I2C_OK;
}

uint8_t rtc_8825_adc_testmode(uint8_t channel)
{
	uint8_t buf;

	rtc_set_channel(channel, RTC_SD8825);
    HAL_Delay(5);
	buf = 0x40;
	if(drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_CTR3, 1, &buf) != WAVE1006_EXIT_OK)   //如果是有应该先关闭32K输出(默认为关闭SD3068的32K)
	{
		return I2C_NO_ACK;
	}
	//选择为SD8825封装(必须在进测试模式之前选择，否则芯片pad改变)
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)   //回读ram21
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x0f;
	buf |= 0x00;//根据pad配置表，编号0为8825
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 20, 1, &buf) != WAVE1006_EXIT_OK)//写入部分ram21寄存器
	{
		return I2C_NO_ACK;
	}
	if (wave1006_enter_test_mode(WAVE1006_TEST_PAD | WAVE1006_TEST_ADC) != WAVE1006_EXIT_OK)   //此处一定要注意，没进入测试模式也需要将I0切换掉，或者不能继续运行程序
	{
		return I2C_NO_ACK;
	}
	// UsbPrintf("pad change OK\n");
	HAL_Delay(5);
	rtc_set_channel(channel, RTC_SD8825);
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK) 
	{
		return I2C_NO_ACK;
	}
	buf &= ~0x38;   //清0 RuleTempAdj[2:0]      //ADC尺子 5
	buf |=  0x28;
	if (drv_wave1006_write_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 19, 1, &buf) != WAVE1006_EXIT_OK)
	{
		return I2C_NO_ACK;
	}
	return I2C_OK;
}

uint8_t rtc_1006_exit_testmode(uint8_t channel)
{
	uint8_t buf = 0x00;
		
	// UsbPrintf("try to exit testmode\n");
	buf = 0x00;
	if (rtc_write_multi_bytes(RTC_8825_ADDRESS, WAVE1006_REG_EXTEND , &buf, 1) != I2C_OK) {
		// rtc_set_channel(channel, RTC_INIT_1006);
		UsbPrintf("warning! RTC exit testmode fail!\n");
		log_printf("warning! RTC exit testmode fail!\n");
		return I2C_NO_ACK;
	} 
	// rtc_set_channel(channel, RTC_INIT_1006);
	// UsbPrintf("exit testmode success\n");
	return I2C_OK;
}



uint16_t rtc_convert_temp_offset(float rtc_adc, float system_temp)
{
	uint16_t offset;
	offset = (uint16_t)(((rtc_adc - (system_temp + 60) * 2)) * 2 - 48);//详见芯片设计手册，起始-60度，地址为0x30;每1bitADC，对应2位otp；每1℃对应2bitADC；
	return offset;
}

uint16_t rtc_init_test_cap(float temp)
{
	uint16_t cap = 480;
	if (temp > -45 && temp <= -35)		//-40
	{
		cap = 220;
	}
	else if (temp > -15 && temp <= -5)	//-10
	{
		cap = 380;
	}
	else if (temp > 10 && temp <= 35)		//29
	{
		cap = 480;
	}
	else if (temp > 55 && temp <= 65)		//60
	{
		cap = 380;
	}
	else if (temp > 80 && temp <= 90)		//85
	{
		cap = 220;
	}
	return cap;
}

/*
OSCCapSel<12:11>	"振荡器引脚OSCIN和OSCOUT粗调电容选择项。
00:0pF
01:1.5pF
10:3.0pF
11:4.5pF"	
OSCCapSel<10:6>	"振荡器引脚OSCIN和OSCOUT次级粗调电容选择项。步进为408fF"
OSCCapSel<5:3>	"振荡器引脚OSCIN细调电容选择项。步进为51fF"
OSCCapSel<2:0>	"振荡器引脚OSCOUT细调电容选择项。步进为51fF"	
*/
// float cap_uint_to_float(uint8_t cap1, uint8_t cap2)
// {
// 	float convert = 0;
// 	uint16_t cap_config = 0;
// 	cap_config = ((cap2 & 0x07) << 5) | (cap1 >> 3);
// 	convert = 1.5 * ((cap2 >> 3) & 0x03) + cap_config * 0.051;
// 	return convert;
// }

// float cap_config_to_float(uint8_t mode, uint8_t cap)
// {
// 	float convert = 0;
// 	convert = 1.5 * mode + cap * 0.051;
// 	return convert;
// }

// void cap_config_to_uint(uint8_t mode, uint8_t cap, uint8_t* cap_buf)
// {
// 	cap_buf[0] = ((cap & 0xff) << 3) | (cap & 0x07);
// 	cap_buf[1] = ((mode & 0x03) << 3) | ((cap & 0xff) >> 5);
// }
// void cap_float_to_uint(float f_cap, uint8_t *p_dat1, uint8_t *p_dat2)
// {
// 	float convert;
// 	uint16_t cap_config = 0;
// 	convert = f_cap - SD8800_CAP_MIN;//固定大电容
// 	cap_config = convert / 0.051;//矩阵小电容
// 	*p_dat2 = (SD8800_CAP_MODE << 3) | ((cap_config & 0xff) >> 5);
// 	*p_dat1 = ((cap_config & 0xff) << 3) | (cap_config & 0x07);

// }

void cap_list_to_uint(uint16_t number, uint8_t* cap_buf)
{
	if (number < SD8800_CAP_LIST_MAX) {
		cap_buf[1] = g_capList[number][0];
		cap_buf[0] = g_capList[number][1];
	}
}

// 
uint16_t cap_list_number_convert(uint16_t start, float ppm)
{
	float sum3d6 = 3.6 * CAP_STEP_3D6;
	float sum2d4 = 2.4 * (CAP_STEP_2D4 - CAP_STEP_3D6);
	float sum1d2 = 1.2 * (CAP_STEP_1D2 - CAP_STEP_2D4);
	float sum0d8 = 0.8 * (CAP_STEP_0D8 - CAP_STEP_1D2);
	float sum0d6 = 0.6 * (CAP_STEP_0D6 - CAP_STEP_0D8);
	float sum0d4 = 0.4 * (start - CAP_STEP_0D6);
	uint16_t number = 1;
	if (ppm < sum0d4) {
		number = start - ppm * 2.5;
	} else {
		ppm -= sum0d4;
		if (ppm < sum0d6) {
			number = CAP_STEP_0D6 - ppm / 0.6;
		} else {
			ppm -= sum0d6;
			if (ppm < sum0d8) {
				number = CAP_STEP_0D8 - ppm / 0.8;
			} else {
				ppm -= sum0d8;
				if (ppm < sum1d2) {
					number = CAP_STEP_1D2 - ppm / 1.2;
				} else {
					ppm -= sum1d2;
					if (ppm < sum2d4) {
						number = CAP_STEP_2D4 - ppm / 2.4;
					} else {
						ppm -= sum2d4;
						if (ppm < sum3d6) {
							number = CAP_STEP_3D6 - ppm / 3.6;
						} else {
							number = 1;
						}
					}
				}
			}
		}
	}
	return number;
}

int digtal_adj_convert(uint16_t start, float ppm)
{
	float sum;
	int digtal = 0;
	
	sum =  1.2 * (CAP_STEP_1D2 - CAP_STEP_2D4) + 0.8 * (CAP_STEP_0D8 - CAP_STEP_1D2)
			+ 0.6 * (CAP_STEP_0D6 - CAP_STEP_0D8) + 0.4 * (start - CAP_STEP_0D6);
	if (ppm < sum) {
		return 0;
	} else {
		digtal = sum - ppm;
		if (digtal < -189) {//数字补偿只有6bit，最大值为63，对应的数为-189
			digtal = -189;
		}
		return digtal;
	}
}

uint8_t wave1006_read_temp_adc(uint16_t* temp)
{
	uint8_t buffer[2] = {0};
	buffer[0] = 0x10;
	uint8_t i;
	
	// if (drv_wave1006_write_reg(DEV_SD3068, 0x17, 1, &buffer[0]) != WAVE1006_EXIT_OK) {
	if (drv_wave1006_write_reg(DEV_SD3068, 0x57, 1, &buffer[0]) != WAVE1006_EXIT_OK) {
		return 0;
	}
	for (i = 0; i < 10; i++) {
		HAL_Delay(1);
		drv_wave1006_read_reg(DEV_SD3068, 0x57, 1, buffer);
		if ((buffer[0] & 0x30) == 0) {
			break;
		}
	}
	if (i >= 10) {return 0;}
	if (drv_wave1006_read_reg(DEV_SD3068, WAVE1006_REG_USER_RAM_START + 26, 2, buffer) != WAVE1006_EXIT_OK)  //读ram26、ram27  
	{
		return 0;
	}
	*temp = buffer[0];
	if (buffer[1] & 0x40) {
		*temp += 256;
	}
	return 1;
}


uint8_t sd8825_out_freq(void)
{
	uint8_t Hz1[5] = {0x40, 0x00, 0x10, 0x00, 0x10};
	uint8_t buffer[5] = {0};
	uint8_t i, j;
	for (i = 0; i < 3; i++) {
		if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x0B, Hz1, 5) == I2C_OK) {//开启输出
			rtc_read_multi_bytes(RTC_8825_ADDRESS, 0x0B, buffer, 5);
			for (j = 0; j < 5; j++) {
				if (buffer[j] != Hz1[j]) {
					break;
				}
			}
			if (j == 5) {
				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13, GPIO_PIN_RESET);
				HAL_GPIO_WritePin(GPIOD, GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
				return I2C_OK;
			} 
		}
	}
	return I2C_NO_ACK;
}

uint8_t sd8825_close_freq(void)
{
	uint8_t buf, j;
	buf = 0x00;
	for (j = 0; j < 10; j++) {
		if (check_sda_level()) {
			if (rtc_write_multi_bytes(RTC_8825_ADDRESS, 0x0d, &buf, 1) == I2C_OK) {
				buf = 0xff;
				rtc_read_multi_bytes(RTC_8825_ADDRESS, 0x0d, &buf, 1);
				if (buf == 0) {
					return I2C_OK;
				}
			} 
		}
		HAL_Delay(20);
	}
	
	return I2C_NO_ACK;
}
